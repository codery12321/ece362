<!DOCTYPE html>
<!-- saved from url=(0047)https://engineering.purdue.edu/ece362/lab/lab2/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
        	<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="https://engineering.purdue.edu/ece362/images/favicon362.png">
	<link rel="icon" type="image/png" sizes="32x32" href="https://engineering.purdue.edu/ece362/images/favicon362.png">
	<link rel="icon" type="image/png" sizes="16x16" href="https://engineering.purdue.edu/ece362/images/favicon362.png">


	<link rel="stylesheet" type="text/css" href="./ECE 362 Lab Experiment 2_files/style.css">
    <title>ECE 362 Lab Experiment 2</title>
    <style>
        /* Self-explanatory, and it looks nice */
        html {
            scroll-behavior: smooth;
        }

        /* AD2 vs ADALM2000 styling */
        .tbl {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .tbl tbody {
            width: 100%;
        }
        .tbl th {
            width: 2.5%;
            padding: 0.5% 2% 0.5% 2%;
            text-align: center;
        }
        .tbl th:not(:first-child) { /* recursive - applies to all children, not just one */
            width: 48.75%;
            border-left: 1px solid black;
        }
        .tbl > tbody > tr:not(:first-child) > th {
            font-weight: 200;
        }
        .tbl tr {
            width: 100%;
            border: 1px solid black;
            display: flex;
        }
        figcaption {
            text-align: center;
        }
        .lab_img {
            width: 100%;
            margin-top: 2%;
        }

        /* ToC styling */
        .toc {
            width: 100%;
        }
        .toc th {
            border: 1px solid black;
            padding: 0 1% 0 1%;
        }
        .toc > tbody > tr:first-child > th { 
            text-align: center;
        }
        .toc > tbody > tr:not(:first-child) > th { 
            font-weight: 200;
        }
        .toc > tbody > tr > th:first-child, .toc > tbody > tr > th:last-child {
            text-align: center;
        }
        .toc tbody {
            width: 100%;
        }
        .toc tr {
            width: max-content;
        }
        h2 {
            margin-top: 3%;
        }

        /* Checklist styling */
        .chklst {
            list-style: none;
            padding-left: 20px;
        }
        .chklst > li {
            display: flex;
            flex-direction: row;
            align-items: center;
            margin-bottom: 0.75%;
        }
        .spanbox {
            position: absolute;
            width: 25px;
            height: 25px;
            background-color: transparent;
            border-radius: 5px;
            transition: background-color 0.3s; 
        }
        .chkbox {
            width: 25px;
            height: 25px;
            padding: 0;
            margin: 0 10px 0 0;
            border-radius: 5px;
            display: block;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .chkbox .inputbox {
            position: absolute;
            opacity: 0;
            z-index: 2;
            width: 25px;
            height: 25px;
        }
        .chkbox .inputbox:checked ~ .spanbox {
            background-color: dimgray;
        }

    </style>
</head>
<body>
	<header>
        <h1>ECE 362 Lab Experiment 2: Assembly Programming</h1>
        		<nav>
		<a href="https://engineering.purdue.edu/ece362/">Home</a>

		<a href="https://engineering.purdue.edu/ece362/about/">About</a>
		<a href="https://engineering.purdue.edu/ece362/refs/">References</a>

		<a href="https://engineering.purdue.edu/ece362/lecture/">Lecture</a>
		<a href="https://engineering.purdue.edu/ece362/hw/">Homework</a>
		<a href="https://engineering.purdue.edu/ece362/lab/">Labs</a>


<!--
-->
<!--
-->
		</nav>

	</header>
        <h2>Introduction</h2>

        <p>
          Now that you know how to use an Integrated Development
          Environment and use assembly instructions, it is time to
          actually do some programming. In the prelab assignment, you
          will test your knowledge of how various instructions
          actually work. For the in-lab experiment, you will write
          short assembly language programs that perform simple tasks.
        </p>

        <p>
          Now that you know that the hardware in your lab kit works,
          you are comfortable with creating projects, and you've had
          some experience typing in programs, you will be expected to
          complete this lab autonomously.  If you need help, ask a
          teaching assistant.  This lab will also not need to be
          evaluated when you finish it.  You will receive a completion
          code on the serial port as you did with Lab 0.
        </p>

        <h2>Instructional Objectives</h2>
        <ul>
          <li>Analyze the operation of simple assembly instructions.</li>
          <li>Practice writing assembly language routines which perform simple tasks.</li>
        </ul>
        <h2 id="toc">Table of Contents</h2>
        <table class="toc">
          <tbody><tr>
            <th>Step</th>
            <th>Description</th>
            <th>Points</th>
          </tr>
          <!-- TODO -->
          <tr>
            <th>0</th>
            <th><a href="https://engineering.purdue.edu/ece362/lab/lab2/#Prelab">Prelab Exercises</a></th>
            <th>40</th>
          </tr>
          <tr>
            <th>1</th>
            <th><a href="https://engineering.purdue.edu/ece362/lab/lab2/#Background">Background on assembler directives</a></th>
            <th></th>
          </tr>
          <tr>
            <th>2</th>
            <th><a href="https://engineering.purdue.edu/ece362/lab/lab2/#Experiment">Experiment</a></th>
            <th></th>
          </tr>
          <tr>
            <th>3</th>
            <th><a href="https://engineering.purdue.edu/ece362/lab/lab2/#Postlab">Submit your postlab results</a></th>
            <th>60</th>
          </tr>
          <tr>
            <th>4</th>
            <th><a href="https://engineering.purdue.edu/ece362/lab/lab2/#Clean">Clean up and log out</a></th>
            <th>(-20)</th>
          </tr>
          <tr>
            <th>&nbsp;</th>
            <th>Total: </th>
            <th>100</th>
          </tr>
        </tbody></table>
        <p>* All the points for this lab depend on proper completion of and submission of your post-lab results.</p>
        <a href="https://engineering.purdue.edu/ece362/lab/lab2/#Checklist"><p>When you are ready for your lab evaluation, review this checklist.</p></a>

        <h2 id="Prelab">Step 0: Prelab Exercises:</h2>
        <ul>
          <li>Be familiar with lectures up to and including (04) Assembly Language Programming.</li>
          <li>Read this entire lab document.</li>
          <li>Ensure that your development board and serial port are working <b>before</b> you start the lab.</li>
          <li>Do the <a href="https://engineering.purdue.edu/ece362/submit/?item=prelab2">prelab exercises</a> and submit them <b>before</b> attempting the lab experiment.</li>
        </ul>

        <h2 id="Background">Step 1: Background understanding for program generation</h2>

        <h3>1.1 Computer Architecture, Instruction Sets, and the Thumb ISA</h3>

        <p>

          The set of rules and methods which govern the functionality,
          organization, and implementation of a particular
          microprocessor is known as that microprocessor's
          architecture. Architecture can be broadly categorized into
          two subdomains: microarchitecture and instruction set
          architecture (ISA).  Microarchitecture can be thought of as
          the hierarchical organization and implementation of a given
          computer processor. Details such as the size and types of
          system buses, hardware-level low-power features, and
          hardware-level interrupt support, are described in a
          microprocessor's microarchitecture. A thorough treatment of
          microarchitecture is beyond the scope of this course, and
          will be covered in more advanced courses within the ECE
          curriculum. Programming a microprocessor requires the use of
          a set of instructions which it recognizes. The list of
          supported instructions, arguments, and modes supported by a
          microprocessor is known as its instruction set architecture,
          or ISA. It can be thought of as the "contract" between
          hardware and software; an ISA is a guarantee to a programmer
          of a given device regarding which instructions will be
          available.

        </p>

        <h3>1.2 Assembler Directives</h3>
        <p>

          In embedded applications, especially when performance is
          key, programs are written in assembly language. You should
          have some familiarity with assembly programming from the
          previous lab. An assembly program cannot run directly on the
          microcontroller, it needs to be converted to a binary
          (machine code) which the microcontroller can
          understand. This is done using an assembler and linker.
        </p>

        <p>
          When an assembly program is written, most of the code is
          intended to be instructions for the CPU. However, there are
          some keywords that instruct the assembler to perform
          specific actions when converting the assembly program to
          binary, these are called assembler directives. All assembler
          directives have names that begin with a period (‘.’). The
          rest of the name is letters, usually in lower case.  Here is
          a small list of assembler directives that are useful for
          ECE362:

        </p>

        <p>Here is a small list of assembler directives that are useful for ECE 362:
        </p>

        <ul>
          <li><b>.text</b> .text: The memory addressed by a CPU is
            generally broken down into four basic blocks or segments
            text, data, heap and stack. The text segment is set of
            memory locations used for storing instructions. All the
            instructions for a program are stored in text segment
            which is read only.  Any attempt to write to this memory
            will result in a fault or exception. Anything in the
            assembly file following the ".text" keyword will be placed
            in the text segment by the assembler. There can be
            multiple uses of the .text directive in a single file, and
            they can be intermingled with .data references (see
            below). The final result will be that all text segment
            entries will be merged together into a contiguous block of
            read-only memory.</li>

          <li><b>.data</b> The data segment is a set of memory locations used
              for storing mutable data related to the assembly program. Unlike
              the ".text" section the .data section allows both reads
              and writes. Anything in the assembly file following the
              ".data" keyword will be placed in the data
              segment. There can be multiple uses of the .data
              directive in a single file, and they can be intermingled
              with .text references. The final result will be that all
              data segment entries will be merged together into a
              single contiguous block of read/write memory.
              <br>

              Most ".data" usages are followed by a label and an
              assembler directive.  <b>A label is an address</b> that is
              calculated by the assembler. This allows the programmer
              to refer to addresses with "names" (i.e. the labels)
              rather than the actual address. It is important to
              understand that a <b>label is an address. Did we mention
              that a label is an address?</b>
              <br>
              Example:
              <pre>                lsls r0, #1
                ...
                ...
                ldr r0, =quot

                .data
                quot: .byte 0x56
              </pre>
              <br> Here "quot" is the label (<b>a label is an
              address</b>) and the value of "quot" is the first
              address/memory location allocated under the data
              segment. At the address "quot" we instruct the assembler
              to store the byte 0x56. And the instruction ldr r0,=quot
              puts the address of the byte 0x56 (i.e. quot which is an
              address) in register r0. Note that this is different
              than putting 0x56 in register r0. It’s putting the
              address in r0. If you wanted to subsequently load the
              single-byte value stored at that address into r1, you
              could then use this instruction:
              <pre>                ldrb r1,[r0]
              </pre>
          </li>

          <li><b>.byte &lt;value&gt;</b> This instructs the assembler
              to store a single byte specified by &lt;value&gt; at the
              location ".byte" is encountered. In the previous example
              we encountered it at "quot" which is the first address
              under the .data section, hence the assembler places the
              byte 0x56 at the address "quot" (remember: a label is an
              address).</li>

          <li><b>.word &lt;value&gt;</b> This instructs the assembler
            to store a single word (in the case of ECE362, 32 bits)
            specified by &lt;value&gt; at the location ".word" is
            encountered. This is similar to ".byte" except that the
            value is 32 bits rather than 8 bits in case of a byte.</li>

          <li><b>.hword &lt;value&gt;</b> This is also similar to
            ".byte" except that the value stored is 16 bits (in the
            context of ECE362).</li>

          <li><b>.string "&lt;characters...&gt;"</b> or <b>.asciz
              "&lt;characters...&gt;"</b> This allocates a chunk of
              memory equal in size to the count of the characters
              inside the quotation marks PLUS ONE. The extra allocated
              byte is at the end of the characters and is
              automatically set to 0x00.  This is the indicator for
              the end of the string.  It is a string of <a href="https://engineering.purdue.edu/ece362/refs/ascii.html">ASCII-encoded</a>
              characters terminated by a zero (asciz).  Using the
              directive like this: <b><code>.string "ABC"</code></b>
              would result in the following four bytes being placed
              contiguously: 0x41, 0x42, 0x43, 0x00.</li>

          <li><b>.space &lt;S&gt;</b> The ".space" fills the number of bytes
                specified by S with zeroes. The zeroes are filled at
                the location/address .space is encountered.</li>

          <li><b>.balign &lt;A&gt;</b> The ".balign" directive instructs the
              assembler to check if the address it encountered .balign
              is divisible by &lt;A&gt;, if not, the assembler will
              "pad" the memory location with zeroes until the address
              is divisible by &lt;A&gt;.  For instance, if the statement
              <b><code>.balign 16</code></b> appeared in code, a
              sufficient number of zeros would be inserted so that the
              next instruction or space reservation would occur on an
              address that is evenly divisible by 16.</li>

        </ul>

        <p>This is a small subset of assembler directives. A more
        complete list is
        available <a href="https://sourceware.org/binutils/docs/as/Pseudo-Ops.html">here</a>.</p>

        <h3>Using the memory browser</h3>
        <p>System Workbench allows you to use the debugger to observe
          memory locations in real-time as they are modified.
          Listings can be rendered in a variety of formats, including
          bytes, integers, and characters.  Consider the following
          assembly language program:
          <b></b></p><pre><b>            .cpu cortex-m0
            .thumb
            .syntax unified
            .fpu softvfp
            .text
            .global main
            main:
                ldr  r1, =array
                ldr  r0,[r1]
                adds r0,#1
                str  r0,[r1]
                ldr  r0,[r1,#4]
                adds r0,#2
                str  r0,[r1,#4]
                bkpt
            .data
            array:
                .word 0
                .word 0
          </b></pre>

          You will only see the memory browser in the "debug
          perspective" of SystemWorkbench.  By default, the memory
          browser may not be open, if not, go to
          <b>Window &gt;&gt; Show View &gt;&gt; Memory Browser</b>.  When open,
          you will see a tab as in Figure 1.


        <figure>
          <img class="lab_img" src="./ECE 362 Lab Experiment 2_files/memory-browser.png">
          <b><figcaption>Figure 1: Memory Browser</figcaption></b>
        </figure>

        <p>
          Since we want to observe the address 0x20000000, we enter
          the address in hex into the text box next to the "*". This
          should start rendering the memory from the microcontroller
          (see Figure 2). On the left most side of the tab is the
          address in memory, followed by the contents of that memory
          location. The default rendering is hexadecimal and <a href="https://engineering.purdue.edu/ece362/refs/ascii.html">ASCII</a>
          text (the text is rendered at the right most side of the
          memory browser).
        </p>



        <figure>
          <img class="lab_img" src="./ECE 362 Lab Experiment 2_files/integer-browser.png" style="width: 20em">
          <b><figcaption>Figure 2: Memory at address 0x20000000</figcaption></b>
        </figure>

        <p>
          To make it easier to observe changes and byte boundaries we
          shall make the following configuration changes to the memory
          browser. To make these changes right click within
          the <b>Memory Browser &gt;&gt; Columns &gt;&gt; 4</b>.
          Similarly right click on the <b>Memory Browser &gt;&gt; Cell
          Size &gt;&gt; 4 Bytes</b>. And similarly right click
          <b>Memory Browser &gt;&gt; Radix &gt;&gt; Decimal
          Signed</b>.  Now step through your program. When a change is
          made to a memory location, it is highlighted in red as seen
          in Figure 3.
        </p>

        <figure>
          <img class="lab_img" src="./ECE 362 Lab Experiment 2_files/memory-change.png" style="width: 30em">
          <b><figcaption>Figure 3: Changes to memory are highlighted in <font color="red">red</font></figcaption></b>
        </figure>


        <p>
          Memory browser is a versatile tool. A lot more features are
          baked into the Memory browser in Eclipse, however the tutorial
          provided here should be more than sufficient to see you
          through ECE 362.
        </p>

        <p>
          Try the prelab exercises with the memory browser to make
          sure you can view changes and understand what is being
          updated.
        </p>

        <h2 id="Experiment">2.0 Experiment</h2>
<!--
        <p>
          When you are comfortable with the SystemWorkbench memory
          browser, you can start the lab experiment.  The experiment
          will be done entirely within the post-lab submission page.
          When you click on the <b>Begin Experiment</b> button, two
          things will happen:
          <ul>
            <li>Your prelab submission will become
            unmodifiable.  <b>Make sure you are satisfied with your
            prelab submission <u>before</u> you begin the lab
            experiment.</b></li>

            <li>You will be given six hours to complete the lab
              exercise.  The six hours starts at the time you
              click <b>Begin Experiment</b>.  Make sure you are
              ready to begin before you click.</li>
          </ul>
-->

        <p>
          You will not receive the exercises you are to implement until
          you are in your lab section.
          You will be given two problems that consist of short
          programs written in C.  They will be similar to those that
          you did in the prelab.  These programs are short enough that
          they can be done in an hour even if you are a new assembly
          language programmer.  Nevertheless, we give you the full lab
          time and the assistance of TAs to work through any
          difficulties (technical or otherwise) that you need to work
          through.
        </p>

        <p>
          You will also be given an autotest.o module that is
          specific to your particular problem set.  It will
          indicate success on the serial port that you've
          used for previous labs.
        </p>

        <p>
          Another reason this lab is constructed this way is to
          try out some of the mechanisms we will use for lab
          practical exams.
        </p>



    <h2 id="Postlab">3 Submit your postlab results</h2>

        <p>
          Once your lab experiment works to your satisfaction, and you
          see how many parts work correctly on the serial port.
          The autotest module will display a
          code on the serial port similar to that of Lab 1.  This code is
          a cryptographic confirmation of your completion of the lab
          experiment as well as your identity and your score.
          (Remember to change the "login" variable from "xyz" to your
          login.)  It is normal for the code to change every time you
          run it.  Choose one of the codes and carefully enter all 32
          characters into
          the <!--a href="https://engineering.purdue.edu/ece362/submit/?item=postlab2"-->postlab
          submission<!--/a--> for this lab experiment.
        </p>

        <p>
          For this lab, and most to follow, you must also submit the
          program that you wrote so that it can be checked by the
          course staff.  Either upload the file or copy it from
          SystemWorkbench and paste it into the text box.  Make sure
          that your entire program is shown there.
        </p>

    <h2 id="Clean">4 Clean up and log out</h2>

        <p>
          No one wants to arrive at a lab station that has a mess left
          by the previous student.  You also don't want to leave your
          lab station computer logged in.  That would allow someone to
          access your files.  These are important enough that we assign
          a penalty for not doing them.  Clean up.  Log out.
        </p>

        <h2 id="Checklist">Lab Evaluation Checklist</h2>
        <p>
          Normally, we'll have a checklist of things that you should review
          before going into your evaluation.  There will be no evaluation
          for this lab experiment.
          </p><ul class="chklst">
             <li><div class="chkbox"><input class="inputbox" type="checkbox"><span class="spanbox"></span></div>
                You did not share your microcontroller with anyone else, right?
                We will know if you did.
             </li>
             <li><div class="chkbox"><input class="inputbox" type="checkbox"><span class="spanbox"></span></div>
                You checked that the integer subroutine works as it should.
             </li>
             <li><div class="chkbox"><input class="inputbox" type="checkbox"><span class="spanbox"></span></div>
                You checked that the character subroutine works as it should.
             </li>
             <li><div class="chkbox"><input class="inputbox" type="checkbox"><span class="spanbox"></span></div>
               You cleaned up your lab station and logged out before you left.
             </li>
          </ul>
        <p></p>

    	<footer>
		<p>Questions or comments about the course and/or the content of these
		webpages should be sent to the <a href="mailto:ece362@ecn.purdue.edu">
		Course Webmaster</a>.  All the materials on this site are intended
		solely for the use of students enrolled in ECE 362 at the Purdue
		University West Lafayette Campus.  Downloading, copying, or
		reproducing any of the copyrighted materials posted on this site
		(documents or videos) for anything other than educational purposes
		is forbidden.</p>
	</footer>



</body></html>