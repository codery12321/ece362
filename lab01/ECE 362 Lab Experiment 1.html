<!DOCTYPE html>
<!-- saved from url=(0047)https://engineering.purdue.edu/ece362/lab/lab1/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
        	<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="https://engineering.purdue.edu/ece362/images/favicon362.png">
	<link rel="icon" type="image/png" sizes="32x32" href="https://engineering.purdue.edu/ece362/images/favicon362.png">
	<link rel="icon" type="image/png" sizes="16x16" href="https://engineering.purdue.edu/ece362/images/favicon362.png">


	<link rel="stylesheet" type="text/css" href="./ECE 362 Lab Experiment 1_files/style.css">
    <title>ECE 362 Lab Experiment 1</title>
    <style>
        /* Self-explanatory, and it looks nice */
        html {
            scroll-behavior: smooth;
        }

        /* AD2 vs ADALM2000 styling */
        .tbl {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .tbl tbody {
            width: 100%;
        }
        .tbl th {
            width: 2.5%;
            padding: 0.5% 2% 0.5% 2%;
            text-align: center;
        }
        .tbl th:not(:first-child) { /* recursive - applies to all children, not just one */
            width: 48.75%;
            border-left: 1px solid black;
        }
        .tbl > tbody > tr:not(:first-child) > th {
            font-weight: 200;
        }
        .tbl tr {
            width: 100%;
            border: 1px solid black;
            display: flex;
        }
        figcaption {
            text-align: center;
        }
        .lab_img {
            width: 100%;
            margin-top: 2%;
        }

        /* ToC styling */
        .toc {
            width: 100%;
        }
        .toc th {
            border: 1px solid black;
            padding: 0 1% 0 1%;
        }
        .toc > tbody > tr:first-child > th { 
            text-align: center;
        }
        .toc > tbody > tr:not(:first-child) > th { 
            font-weight: 200;
        }
        .toc > tbody > tr > th:first-child, .toc > tbody > tr > th:last-child {
            text-align: center;
        }
        .toc tbody {
            width: 100%;
        }
        .toc tr {
            width: max-content;
        }
        h2 {
            margin-top: 3%;
        }

        /* Checklist styling */
        .chklst {
            list-style: none;
            padding-left: 20px;
        }
        .chklst > li {
            display: flex;
            flex-direction: row;
            align-items: center;
            margin-bottom: 0.75%;
        }
        .spanbox {
            position: absolute;
            width: 25px;
            height: 25px;
            background-color: transparent;
            border-radius: 5px;
            transition: background-color 0.3s; 
        }
        .chkbox {
            width: 25px;
            height: 25px;
            padding: 0;
            margin: 0 10px 0 0;
            border-radius: 5px;
            display: block;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .chkbox .inputbox {
            position: absolute;
            opacity: 0;
            z-index: 2;
            width: 25px;
            height: 25px;
        }
        .chkbox .inputbox:checked ~ .spanbox {
            background-color: dimgray;
        }

    </style>
</head>
<body>
	<header>
        <h1>ECE 362 Lab Experiment 1: "First Blinks"</h1>
        		<nav>
		<a href="https://engineering.purdue.edu/ece362/">Home</a>

		<a href="https://engineering.purdue.edu/ece362/about/">About</a>
		<a href="https://engineering.purdue.edu/ece362/refs/">References</a>

		<a href="https://engineering.purdue.edu/ece362/lecture/">Lecture</a>
		<a href="https://engineering.purdue.edu/ece362/hw/">Homework</a>
		<a href="https://engineering.purdue.edu/ece362/lab/">Labs</a>


<!--
-->
<!--
-->
		</nav>

	</header>
        <h2>Introduction</h2>

        <p>

          Traditionally, the "first steps" taken to verify that a
          microcontroller works and that you know how to use it, is to
          make a light blink. In this introductory exercise, you will
          use an integrated development environment (IDE) to interact
          with a microcontroller. You will type in, compile, and debug
          a few programs that we have prepared for you. One of the
          programs will cause the built-in LEDs of the
          STM32F091 development board to blink. You will also
          write a few simple assembly language subroutines.
        </p>

        <p>
          Now that you know that the hardware in your lab kit works,
          you are comfortable with creating projects, and you've had
          some experience typing in programs, you will be expected to
          complete this lab autonomously.  If you need help, ask a
          teaching assistant.  In lab, you will receive help for and
          be checked off for subroutines that you complete.  You will
          also be given a module that will evaluate the subroutines.
          It will generate a completion code on the serial port as
          with Lab 0.
        </p>

        <h2>Instructional Objectives</h2>
        <ul>
          <li>Type in, compile, and debug simple assembly language programs.</li>
          <li>Analyze the operation of simple assembly instructions.</li>
          <li>Practice writing assembly language routines which perform simple tasks.</li>
        </ul>
        <h2 id="toc">Table of Contents</h2>
        <table class="toc">
          <tbody><tr>
            <th>Step</th>
            <th>Description</th>
            <th>Points</th>
          </tr>
          <!-- TODO -->
          <tr>
            <th>0</th>
            <th><a href="https://engineering.purdue.edu/ece362/lab/lab1/#Prelab">Prelab Exercises</a></th>
            <th>10</th>
          </tr>
          <tr>
            <th>1</th>
            <th><a href="https://engineering.purdue.edu/ece362/lab/lab1/#Background">Background understanding for program generation</a></th>
            <th></th>
          </tr>
          <tr>
            <th>2</th>
            <th><a href="https://engineering.purdue.edu/ece362/lab/lab1/#Create">Create a Project</a></th>
            <th></th>
          </tr>
          <tr>
            <th>3</th>
            <th><a href="https://engineering.purdue.edu/ece362/lab/lab1/#Arithmetic">Arithmetic Exercises</a></th>
            <th>40</th>
          </tr>
          <tr>
            <th>4</th>
            <th><a href="https://engineering.purdue.edu/ece362/lab/lab1/#Logical">Logical Operation Exercises</a></th>
            <th>20</th>
          </tr>
          <tr>
            <th>5</th>
            <th><a href="https://engineering.purdue.edu/ece362/lab/lab1/#Shift">Shift Operation Exercises</a></th>
            <th>20</th>
          </tr>
          <tr>
            <th>6</th>
            <th><a href="https://engineering.purdue.edu/ece362/lab/lab1/#Blink">Make the Lights Blink</a></th>
            <th>10</th>
          </tr>
          <tr>
            <th>7</th>
            <th><a href="https://engineering.purdue.edu/ece362/lab/lab1/#Testing">Testing</a></th>
            <th></th>
          </tr>
          <tr>
            <th>8</th>
            <th><a href="https://engineering.purdue.edu/ece362/lab/lab1/#Postlab">Submit your postlab results</a></th>
            <th>*</th>
          </tr>
          <tr>
            <th>&nbsp;</th>
            <th>Total: </th>
            <th>100</th>
          </tr>
        </tbody></table>
        <p>* All the points for this lab depend on proper completion
        of and submission of your post-lab results.</p>
        <a href="https://engineering.purdue.edu/ece362/lab/lab1/#Checklist"><p>When you are ready for your lab
        evaluation, review this checklist.</p></a>

        <h2 id="Prelab">Step 0: Prelab Exercises:</h2>
        <ul>
          <li>Be familiar with lectures up to and including (02)
            Instruction Sets.
          </li>
          <li>Read this entire lab document.  Complete
          the <a href="https://engineering.purdue.edu/ece362/submit?item=prelab1">prelab
          exercises</a> and submit your answers <b>before</b>
          attempting the lab experiment
          </li>
          <li>Read the user manual for the STM32F091 development
            board.
          </li>
          <li>
            Do
          the <a href="https://engineering.purdue.edu/ece362/submit/?item=prelab1">prelab
          exercises</a> and submit them before attempting the lab
          experiment.
          </li>
        </ul>

        <h2 id="Background">Step 1: Background understanding for program generation</h2>

        <h3>1.1 Programming, Compilation, and assembly</h3>

        <p>

          Microcontrollers can be programmed in a manner similar to
          that of a general purpose computer system. However, due to
          memory size constraints of most microcontrollers, the
          software development environment must be hosted on a
          separate computer system. A program written in a high-level
          language such as C or C++ can be translated into assembly
          language by a compiler. In the case where the host system
          CPU differs from the target system CPU, this translator is
          called a cross-compiler. The compiler used for ECE 362 is
          the same as the one you used for your introductory
          programming classes, gcc. This version of gcc has been
          configured as a cross-compiler to produce assembly language
          specifically for the ARM Cortex M0 architecture. Assembly
          language is changed into machine code (also known as object
          code) by an assembler. In the past, you have seen gcc
          apparently produce object code directly as object files with
          a “.o” suffix. It does this by invoking the assembler
          automatically in a way that you never see the intermediate
          assembly language. GCC also knows how to directly accept
          assembly language files with “.s” suffixes and pass them to
          the assembler to generate an object file without ever
          needing initial C code.

        </p>

        <p>

          An object file contains raw machine instructions and other
          data in chunks known as segments. Two of these segments are
          the text and data segments. The object file format is known
          as the Executable and Linking Format (ELF). An ELF object
          file produced for your C or assembly language program cannot
          be directly executed by a computer because it lacks various
          hidden setup and configuration procedures. For instance,
          there is a special procedure that is responsible for calling
          the main() function as well as setting up its
          arguments. These procedures are held in other object
          files. These object files are combined into an executable by
          a linker. The linker searches each object file to find
          references to symbols that remain undefined in that
          file. For instance, object file containing startup code
          refers to main(), but that function is not defined in that
          file. The linker combines the text, data, and other segments
          of multiple object files so that all of those references are
          defined. The resulting file is called an ELF executable
          which can be executed directly by a general purpose
          computer. Unfortunately, the microcontroller on your
          development board has neither an operating system nor any
          kind of loader to interpret an ELF executable.  A final step
          of the program compilation, assembly, and linking process
          involves converting the ELF executable into a raw binary
          image of the desired memory configuration that has no
          segments. This binary file is written directly into the
          flash ROM of your development system. All of the steps of
          compiling, assembling, linking, and converting are automated
          and hidden by the integrated development environment. You
          might look at the project directories that are created in
          the course of this lab exercise to find the object files,
          executables, and binary images that are produced. The
          resulting flow of files for a project might look like Figure 1:

        </p>

        <figure>
          <img class="lab_img" src="./ECE 362 Lab Experiment 1_files/file-flow.png">
          <b><figcaption>Figure 1: Flow of files during a project build</figcaption></b>
        </figure>

        <h3>1.2 ARM Cortex-M0 specific assembler directives</h3>
        <p>

          Most of the code that is written in a .s file is meant to be
          executed on the microcontroller core. However some
          instructions on the .s file instruct the assembler to
          perform a specific task.  Such instructions are called
          assembler directives. For now, we describe the four most
          important ones that are present at the beginning of the .s
          file.<br>

          </p><pre>            .cpu cortex-m0
            .thumb
            .syntax unified
            .fpu softvfp
          </pre>
        <p></p>

        <ul>
          <li><b><code>.cpu cortex-m0</code></b>: Lets the assembler
          know that the target CPU core for this code is a Cortex-M0
          core (i.e., the core supports the ARM Cortex-M0 instruction
          set).  Different types of ARM CPUs, and even different types
          of ARM Cortex CPUs support different groups of instructions.
          It is important for the assembler to know which CPU we want
          to target so that it does not accept an instruction that is
          not supported.</li>
          <li><b><code>.thumb</code></b>: Specifically accept and
          generate only the Thumb 1 and Thumb 2 instructions supported
          by the target CPU.</li>
          <li><b><code>.syntax unified</code></b>: Use the "unified"
          instruction names like <code>ADDS</code> rather than the
          ones listed in the ARM Architecture Reference Manual
          (e.g., <code>ADD</code>).</li>
          <li><b><code>.fpu softvfp</code></b>: Select
          the <em>type</em> of floating-point unit to assemble for.
          The ARM Cortex-M0 lacks floating point hardware, and we
          won't be using floating point in assembly language.  If you
          wanted to specify a global variable in assembly language and
          set it to a floating point value, you would need this
          directive for it to be understood by C-compiled module.</li>
        </ul>

        <h2 id="Create">Step 2: Create a Project</h2>
        <p>
          This lab consists of multiple segments where you are
          expected to type in assembly code. Before you begin you must
          create a project, then you must use the "main.s" template
          file available on the website and add your code in the
          corresponding sections.
        </p>

        <p>
          You created a project in Lab Experiment 0, and you will need
          to do so for each lab experiment in the course.  Create a
          "lab1" project that uses the Standard Peripheral Library
          (StdPeriph).  Although you won't be using any of the
          features of the Standard Peripheral Library in this lab,
          the <code>autotest.o</code> module provided for you relies
          on it.
        </p>

        <p>
          A <code>main.c</code> is automatically created in the
          lab1/src directory.  We won't be using it in this lab, so
          <b><font color="red">delete it</font></b> by right-clicking
          (or option-clicking) on the <code>main.c</code> file and
          selecting "Delete".  Then create a new file named "main.s"
          to hold your assembly language code.  At the top of the
          file, add the four directives explained in section 1.2,
          followed by items that identify you and <em>invoke</em> the
          steps of the experiment you will build, below.
          </p><pre>.cpu cortex-m0
.thumb
.syntax unified
.fpu softvfp

.global login
login: .asciz "xyz"

.align 2
.global main
main:
    //bl   autotest // Uncomment this ONLY when you're not manually invoking below.
    movs r0, #1
    movs r1, #2
    movs r2, #4
    movs r3, #8
    bl   example // invoke the example subroutine
    nop

    movs r0, #35 // replace these values with examples from the prelab
    movs r1, #18
    movs r2, #23
    movs r3, #12
    bl   step31 // invoke Step 3.1
    nop

    movs r0, #10 // replace these values with examples from the prelab
    movs r1, #3
    movs r2, #18
    movs r3, #42
    bl   step32 // invoke Step 3.2
    nop

    movs r0, #24 // replace these values with examples from the prelab
    movs r1, #35
    movs r2, #52
    movs r3, #85
    bl   step33 // invoke Step 3.3
    nop

    movs r0, #29 // replace these values with examples from the prelab
    movs r1, #42
    movs r2, #93
    movs r3, #184
    bl   step41 // invoke Step 4.1
    nop

    movs r0, #0x11 // replace these values with examples from the prelab
    movs r1, #0x22
    bl   step42 // invoke Step 4.2
    nop

    movs r0, #0 // unused as an input operand
    movs r1, #16
    movs r2, #2
    movs r3, #3
    bl   step51 // invoke Step 5.1
    nop

    movs r0, #5
    bl   step52 // invoke Step 5.2
    nop


    bl   setup_portc
loop:
    bl   toggle_leds
    ldr  r0, =500000000
wait:
    subs r0,#83
    bgt  wait
    b    loop

// The main function never returns.
// It ends with the endless loop, above.

// Subroutine for example in Step 3.0
.global example
example:
    // Enter your code here
    bx   lr

// Subroutine for Step 3.1
.global step31
step31:
    // Enter your code here
    bx   lr

// Subroutine for Step 3.2
.global step32
step32:
    // Enter your code here
    bx   lr

// Subroutine for Step 3.3
.global step33
step33:
    // Enter your code here
    bx   lr

// Subroutine for Step 4.1
.global step41
step41:
    // Enter your code here
    bx   lr

// Subroutine for Step 4.2
.global step42
step42:
    // Enter your code here
    bx   lr

// Subroutine for Step 5.1
.global step51
step51:
    // Enter your code here
    bx   lr

// Subroutine for Step 5.2
.global step52
step52:
    // Enter your code here
    bx   lr

// Step 6: Type in the .equ constant initializations below

.global setup_portc
setup_portc:
    // Type in the code here.
    bx   lr

.global toggle_leds
toggle_leds:
    // Type in the code here.
    bx   lr
          </pre>
        <p></p>

        <p>
          Each step in this lab experiment will involve the completion
          of a <em>subroutine</em>.  Unless you have moved
          fast-forward through the lectures, you have not learned how
          subroutines work in assembly language, and that is not a
          problem.  Here, we have set up the subroutines for you.  You
          can think of each <b><code>BL</code></b> instruction as a
          "call" for a named subroutine, and the <b><code>BX
          LR</code></b> is the "return" from that subroutine.  Your
          job is to fill in the code between the label of the
          subroutine (e.g., <code>step31</code>) and the <code>bx
          lr</code>.
        </p>

        <p>
          The <code>main</code> label also defines a subroutine which
          is called by the code
          in <code>startup/startup_stm32.s</code>.  We never return
          from the <code>main</code> subroutine for the code we write
          in this class, so you might not think of <code>main</code>
          as a subroutine.
        </p>

        <p>
          Each step invocation in the <code>main</code> subroutine is
          preceded by one or more <b><code>MOVS</code></b>
          instructions that initialize a few registers.  You may
          change any of these MOVS instructions to do your own testing
          of the assembly code that you write.  In the debugger, use
          the "Step Into (F5)" button to step into each function.
          When the function returns, the code arrives at
          a <b><code>NOP</code></b>.  This is a "no operation"
          instruction.  That we will use as a visual indication that
          this is the point where you should examine the register
          values that were produced by the operations you wrote in the
          subroutine.
          At every point, you should be able to watch the register
          values in the "Registers" tab of the information window
          in the upper right corner of the debugger.
        </p>

        <p>
          When debugging, you may place up to <u>four</u> breakpoints
          anywhere in your assembly code by double-clicking in the
          area just to the left of the line number of main.s.  (If you
          attempt to place more than <u>four</u> breakpoints, the
          debugger will complain, and it will demand that you to
          remove the excess breakpoints before it runs the program.
          Once you set a breakpoint, you can click the "Resume" button
          on the debugger interface to quickly execute code without
          single-stepping through instructions.  In this way, you can
          skip over exercises that you have already completed while
          you work on later exercises that you need to debug.
        </p>

        <h2 id="Arithmetic">Step 3: Arithmetic Exercises</h2>
        <p>
          The subroutines for this step will exercise your knowledge
          of the arithmetic instructions.  Each subroutine is preceded
          by MOVS instructions that initialize registers R0 through
          R3.  The instructions you write should use only registers R0
          through R3.
        </p>

        <h3>3.0: example</h3>
        <p>
          Fill in the subroutine body for <code>example</code> with
          instructions that will set the value of R0 to R0+R1+R2+R3.
          For instance, if you set the values R0 through R3 like this:
          </p><pre>            movs r0, #1
            movs r1, #2
            movs r2, #4
            movs r3, #8
          </pre>
          You should expect that the R0 register will contain the
          value 15 when execution reaches the <code>nop</code>
          following the subroutine invocation.  It does not matter
          what values are left in R1, R2, and R3 after the return
          from <code>example</code>.  Remember to use only the
          registers R0 through R3 when you write your instructions.
        <p></p>
        <h3>Solution for example</h3>
        <p>
          The operation cannot be implemented with a single
          instruction.  You must compose multiple instructions to
          produce the result.
          </p><pre>            .global example
            example:
                adds r1, r0, r1 // now, r1 = r0 + r1
                adds r1, r1, r2 // now, r1 = r0 + r1 + r2
                adds r1, r1, r3 // finally, r1 = r0 + r1 + r2 + r3
                movs r0, r1     // put the result into r0
                bx lr
          </pre>
          You should copy this into the example subroutine in the
          file, and trace through the execution with the debugger to
          make sure you understand how it works.
        <p></p>
        <h3>Another solution for example</h3>
        <p>
          There are usually many ways to write the same high-level operation
          in assembly language.  The fewer instructions you can use, the
          faster the code will run to completion.  Here is another solution
          for the previous problem that has fewer instructions:
          </p><pre>            .global example
            example:
                adds r0, r0, r1 // now, r0 = r0 + r1
                adds r2, r2, r3 // now, r2 = r2 + r3
                adds r0, r0, r2 // finally, r0 = (r0 + r1) + (r2 + r3)
                bx lr
          </pre>
          It may be a little more difficult to understand.  You should
          study it to discover how it works.  For today's exercises, it does
          not matter how slowly your solution works (within reason).  What
          does matter is that no registers other than r0, r1, r2, or r3 are
          modified by the code.  The reasons for doing so may seem a little
          arbitrary, but you'll understand someday when we talk about the
          ARM Cortex Application Binary Interface (ABI) specifications.
        <p></p>

        <h3>3.1: step31</h3>
        <p>
          Fill in the subroutine body for <code>step31</code> with
          instructions that will set the value of the R0 register to
          the expression described in section 3.1 of the prelab.
        </p>
        <p>
          Use the four <b><code>movs</code></b> statements before the
          subroutine is called to set up example values.  You should
          expect that the R0 register will contain the expected result
          when execution reaches the <code>nop</code> following the
          subroutine invocation.  It does not matter what values are
          left in R1, R2, and R3 after the return
          from <code>step31</code>.  Remember to use only the
          registers R0 through R3 when you write your instructions.
        </p>
        <p>
          When the subroutine is working as expected, show your TA.
        </p>

        <h3>3.2: step32</h3>
        <p>
          Do for <b><code>step32</code></b> as you did
          for <b><code>step31</code></b>.
        </p>
        <p>
          When the subroutine is working as expected, show your TA.
        </p>

        <h3>3.3: step33</h3>
        <p>
          Do for <b><code>step33</code></b> as you did
          for <b><code>step31</code></b>.
        </p>
        <p>
          When the subroutine is working as expected, show your TA.
        </p>

        <h2 id="Logical">Step 4: Logical Operation Exercises</h2>
        <h3>4.1: An easy one</h3>
        <p>
          Fill in the subroutine body for <code>step41</code> with
          instructions that implement the logical expression specified
          in the prelab for step 4.1, where
          </p><ul>
            <li>| represents the bitwise OR operator in C
            </li><li>&amp; represents the bitwise AND operator in C
            </li><li>^ represents the bitwise XOR operator in C
            </li><li>~ represents the bitwise inverse operator in C
          </li></ul>
          You should expect that the R0 register will contain the
          expected result when execution reaches the <code>nop</code>
          following the subroutine invocation.  It does not matter
          what values are left in R1, R2, and R3 after the return
          from <code>step41</code>.  Remember to use only
          the registers R0 through R3 when you write your instructions.
        <p></p>
        <p>
          When the subroutine is working as expected, show your TA.
        </p>
        <h3>A few notes:</h3>
        <p>
          The basic logical instructions are ANDS, ORRS, BICS, EORS, and MVNS.
          Read the Architecture Reference Manual to familiarize yourself with
          their operation.
        </p>

        <h3>4.2: Using temporary registers to hold values</h3>
        <p>
          Fill in the subroutine body for <code>step42</code> with
          instructions that will set the value of R0 to the expression
          found in the prelab.
          (Since the logical operations do not support immediate operands,
          you will need to load the constant integer values in the expression
          into temporary registers.)
          For instance, if you want to AND the value 0xff with r0, you might
          say something like:
          </p><pre>            movs r1, #0xff
            ands r0, r1
          </pre>
          You might need to use different register names to implement the
          expression given.
        <p></p>
        <p>
          You should expect that the R0 register will contain the
          expected value when execution reaches the <code>nop</code>
          following the subroutine invocation.  It does not matter
          what values are left in R1, R2, and R3 after the return
          from <code>step41</code>.  Remember to use only
          the registers R0 through R3 when you write your instructions.
          Note that you should implement an operation like (Rx &amp; ~Ry)
          with the <b><code>BICS Rx, Ry</code></b> instruction.
        </p>
        <p>
          When the subroutine is working as expected, show your TA.
        </p>

        <h2 id="Shift">Step 5: Shift Operation Exercises</h2>
        <h3>5.1: An easy one first</h3>
        <p>
          Fill in the subroutine body for <code>step51</code> with
          instructions that will set the value of R0 to (R3 &lt;&lt; R1) &gt;&gt; R2,
          where
          </p><ul>
            <li>&gt;&gt; represents the right shift operator in C
            </li><li>&lt;&lt; represents the left shift operator in C
          </li></ul>
          A left shift by n bits represents a multiplication by
          2<sup>n</sup>, and a right shift by n bits represents a
          division by 2<sup>n</sup>.  For instance, if you set the
          values R0 through R3 like this:
          <pre>            movs r0, #0 // unused as an input operand
            movs r1, #16
            movs r2, #2
            movs r3, #3
          </pre>
          You should expect that the R0 register will contain the
          value 49152 (3*2<sup>16</sup>/2<sup>2</sup> =
          3*2<sup>16-2</sup> = 3*16384) when execution reaches
          the <code>nop</code> following the subroutine invocation.
          Of course, truncation of the result stored in R0 will occur
          if the the initial value in R3 is too large, or either of
          the shift values in R1 or R2 are too large.  For instance,
          (3 &lt;&lt; 48) &gt;&gt; 47 is zero because any left shift
          more than 32 will always shift all of the bits out of the
          register.  It does not matter what values are left in R1,
          R2, and R3 after the return from <code>example</code>.
          Remember to use only the registers R0 through R3 when you
          write your instructions.
        <p></p>
        <p>
          When the subroutine is working as expected, show your TA.
        </p>

        <h3>5.2 Combine With Logical Operations</h3>
        <p>
          Fill in the subroutine body for <code>step52</code> with
          instructions that will set the value of R0 to ((R0 &amp; ~0x1)
          &lt;&lt; 3) | 5, where '~' represents the bitwise inverse of
          the operation.  Note that there is a special instruction
          that implements something like Rx &amp; ~Ry.  You might like to
          use that one.  For instance, if you set the value R0 this:
          </p><pre>            movs r0, #5
          </pre>
          You should expect that the R0 register will contain the
          value 37 when execution reaches the <code>nop</code>
          following the subroutine invocation.  It does not matter
          what values are left in R1, R2, and R3 after the return
          from <code>example</code>.  Remember to use only the
          registers R0 through R3 when you write your instructions.
        <p></p>
        <p>
          When the subroutine is working as expected, show your TA.
        </p>

        <h2 id="Blink">Step 6: Make the Lights Blink</h2>
        <p>
          You have not yet learned how to use general-purpose
          input/output (GPIO), but we can give you some code that will
          do the necessary steps to manipulate the pins of the
          microcontroller and let you fill in some additional assembly
          language to do interesting things.  Four pins of Port C
          (PC6,PC7,PC8,PC9) are connected to four LEDs on the
          development board.  Setting any one of these pins "high"
          will illuminate the appropriate LED.  Soon, this will seem
          like a very easy thing for you to do, but we'll try to give
          you a gentle introduction and encouragement to learn more.
        </p>

        <p>
          Our tradition is to give you code with the expectation that
          you will type it in.  Do not ask someone else to type it in
          for you, and do not share your code with anyone else.  This
          typing is not only practice for the assembly language
          constructs that you will be using, but also practice for
          debugging the mistakes that you will inevitably make when
          you do all that typing.  It is natural to make these
          mistakes, and you will continue to do so through the
          semester (your instructor still makes mistakes typing things
          like this), so the ability to <em>recognize</em> errors
          and <em>recover</em> from them quickly is essential.
        </p>

        <h3>Initialize some constants</h3>
        <p>Type in the following .equ definitions just below the comment
          in <code>main.s</code> for Step 6.
        </p>

        <figure>
          <img class="lab_img" src="./ECE 362 Lab Experiment 1_files/equ-statements.png">
          <b><figcaption>Figure 2: Some .equ initializations</figcaption></b>
        </figure>

        <h3>Configure GPIO</h3>
        <p>
          Type in the following assembly language subroutine to initialize
          the RCC clock for Port C and set up the mode register for Port C
          to configure four pins for output.
        </p>

        <figure>
          <img class="lab_img" src="./ECE 362 Lab Experiment 1_files/setup-portc.png">
          <b><figcaption>Figure 3: Configure Port C</figcaption></b>
        </figure>

        <h3>Toggle LEDs</h3>
        <p>
          Type in the following assembly language subroutine that will
          <em>toggle</em> all four of the pins connected to the LEDs.
        </p>

        <figure>
          <img class="lab_img" src="./ECE 362 Lab Experiment 1_files/toggle-leds.png">
          <b><figcaption>Figure 4: Toggle the LEDs</figcaption></b>
        </figure>

        <p>If you have typed everything in correctly, you should see
          all four LEDs on the development blink at a rate of 1 Hz.
          You can feel free to modify the <code>toggle_leds</code>
          subroutine to try different values.  (For instance, consider
          what happens if you change the line that says
          </p><pre>            ldr r2,=PINS6_TO_9
          </pre>
          to say, instead,
          <pre>            ldr r2,=0x40
          </pre>
          Change <code>toggle_leds</code> all you want.
          It's for your own amusement.  But the other subroutines must
          all work as described.
        <p></p>
        <p>
          When the subroutine is working as expected, show your TA.
        </p>

        <h2 id="Testing">Step 7: Testing</h2>
        <p>
          Once you have tested each of the subroutines to implement
          for this lab, you can install the
          precompiled <a href="https://engineering.purdue.edu/ece362/lab/lab1/autotest.o">autotest.o</a> module for
          the lab as you did for Lab 0 and uncomment the call
          to <code>autotest</code>.  It is an interactive test manager
          that will allow you to check any one of your steps with
          values you specify.  It will also automatically test each of
          the subroutines you implemented with many variations of
          register values to make sure they work exactly as they
          should.
          <b>
            You must be sure to set the <code>login</code> variable to
            the proper string in order to initialize the testing.
          </b>
          Wire the serial port just like you did for lab 0.  The
          subroutines tested are
          <code>example</code>,
          <code>step31</code>,
          <code>step32</code>,
          <code>step33</code>,
          <code>step41</code>,
          <code>step42</code>,
          <code>step51</code>,
          <code>step52</code>, and
          <code>setup_portc/toggle_leds</code>.  If you cannot get the
          <code>example</code> subroutine (which we provided for you) to
          work, you won't get any points.
        </p>

        <p>
          If <code>autotest</code> tells you that only 7/9 of the
          subroutines work properly, you can intentionally make a
          subroutine do the wrong thing by adding a <b><code>movs
          r0,#0</code></b> just before the <code>bx lr</code>
          instruction.  This will force the result to be always be zero.
          If you insert it into the <code>step41</code>
          subroutine, and, if the score remains 7/9, you know that
          <code>step41</code> is one of the two subroutines that does
          not work correctly.  Using this process of elimination, you
          can find all of the subroutines that do not work and repair
          them.  <b>However, it will be easier, in the long run, if
          you carefully test each one as you write it.</b>
        </p>

    <h2 id="Postlab">8 Submit your postlab results</h2>

        <p>
          Once your lab experiment works to your satisfaction, and you
          see how many parts work correctly on the serial terminal,
          get the completion code for your work.  This code is a
          cryptographic confirmation of your completion of the lab
          experiment as well as your identity and your score.
          (Remember to change the "login" variable from "xyz" to your
          login.)  It is normal for the code to change every time you
          run it.  Choose one of the codes and carefully enter all 32
          characters into
          the <a href="https://engineering.purdue.edu/ece362/submit/?item=postlab1">postlab
          submission</a> for this lab experiment.
        </p>

        <p>
          For this lab, and most to follow, you must also submit the
          program that you wrote so that it can be checked by the
          course staff.  Either upload the file or copy it from
          SystemWorkbench and paste it into the text box.  Make sure
          that your entire program is shown there.
        </p>

        <h2 id="Checklist">Lab Evaluation Checklist</h2>
        <p>
          Normally, we'll have a checklist of things that you should review
          before going into your evaluation.  There will be no evaluation
          for this lab experiment.
          </p><ul class="chklst">

            <li><div class="chkbox"><input class="inputbox" type="checkbox"><span class="spanbox"></span></div>
                You did not share your microcontroller with anyone else, right?
                We will know if you did.
             </li>

            <li><div class="chkbox"><input class="inputbox" type="checkbox"><span class="spanbox"></span></div>
                Implement step31.
             </li>

            <li><div class="chkbox"><input class="inputbox" type="checkbox"><span class="spanbox"></span></div>
                Implement step32.
             </li>

            <li><div class="chkbox"><input class="inputbox" type="checkbox"><span class="spanbox"></span></div>
                Implement step33.
             </li>

            <li><div class="chkbox"><input class="inputbox" type="checkbox"><span class="spanbox"></span></div>
                Implement step41.
             </li>

            <li><div class="chkbox"><input class="inputbox" type="checkbox"><span class="spanbox"></span></div>
                Implement step42.
             </li>

            <li><div class="chkbox"><input class="inputbox" type="checkbox"><span class="spanbox"></span></div>
                Implement step51.
             </li>

            <li><div class="chkbox"><input class="inputbox" type="checkbox"><span class="spanbox"></span></div>
                Implement step52.
             </li>

            <li><div class="chkbox"><input class="inputbox" type="checkbox"><span class="spanbox"></span></div>
                Implement setup_portc and toggle_leds.
             </li>

          </ul>
        <p></p>

    	<footer>
		<p>Questions or comments about the course and/or the content of these
		webpages should be sent to the <a href="mailto:ece362@ecn.purdue.edu">
		Course Webmaster</a>.  All the materials on this site are intended
		solely for the use of students enrolled in ECE 362 at the Purdue
		University West Lafayette Campus.  Downloading, copying, or
		reproducing any of the copyrighted materials posted on this site
		(documents or videos) for anything other than educational purposes
		is forbidden.</p>
	</footer>



</body></html>